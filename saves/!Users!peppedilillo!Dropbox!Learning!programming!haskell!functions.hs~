lucky :: (Integral a) => a -> String
lucky 7 = "LUCKY NUMBER SEVEN!"
lucky x = "Sorry, not the lucky number"
-- lol this is how pattern matching looks in haskell?
-- PATTERN MATCHING. patterns are looked top to bottom.
sayMe :: (Integral a) => a -> String
sayMe 1 = "One"
sayMe 2 = "Two"
sayMe 3 = "Three"
sayMe x = "Not betwen 1 and 3"
-- this is another example. now a factorial
factorial :: (Integral a) => a -> a
factorial 1 = 1
factorial x = x * factorial (x - 1)
-- in general the more complex patterns go to the end.
-- always tackle all possible cases. this for example will fail if
-- any char different then a and b is used.
charName :: Char -> String
charName 'a' = "alberto"
charName 'b' = "barbara"
-- let's try with tuples
addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)
-- now compare with others, a function definition in haskell is
-- automatically a catch-all pattern matching thing.
-- `first` and `second` returns the first and second elements of a tuple
-- we can make a `third` function our own:
third :: (a, b, c) -> c
third (_, _, z) = z
xs = [(1, 3), (4, 3), (2, 4), (5, 3), (5, 6)]
xs' = [a + b | (a, b) <- xs]
-- you can patter match against lists. for example:
head' :: [a] -> a
head' [] = error "your list is empty"
head' (x:_) = x
-- note that `(x:_) will not match against the empty list, it requires
-- at least one element, which will become `x`.
-- this is a length function
length' :: (Num b) => [a] -> b
length' [] = 0
length' (_: xs) = 1 + length' xs
-- this is a sum of list function
sum' :: (Num a) => [a] -> a
sum' [] = 0
sum' (x:xs) = x + sum' xs
-- AS PATTERNS. we can use `@` to define an alias for a pattern
capital :: String -> String
capital "" = "Empty string"
capital all@(x:xs) = "The first letter of " ++all ++" is " ++[x]
 -- GUARDS. Guards adds constraints to patterns, for example (lol):
bmiTell :: (RealFloat a) => a -> String
bmiTell bmi
  | bmi <= 18.5 = "underweight"
  | bmi <= 25.0 = "normal"
  | bmi <= 30.0 = "fat"
  -- otherwise is a keyword it seems
  | otherwise = "you're a whale, congrats"
-- another example, a max function
max' :: (Ord a) => a -> a -> a
max' x y
  | x < y     = y
  | otherwise = x
-- now let's try to define a infix function
myCompare :: (Ord a) => a -> a -> Ordering
a `myCompare` b
  | a > b = GT
  | a == b = EQ
  | otherwise = LT
-- WHERE. where is useful to define quantities which can be used by
-- the function avoiding repetitions. for example
bmiTell' :: (RealFloat a) => a -> a -> String
bmiTell' weight height
  | bmi <= 18.5 = "underweight"
  | bmi <= 25.0 = "normal"
  | bmi <= 30.0 = "fat"
  | otherwise = "you're a whale, congrats"
  where bmi = weight / height ^ 2
-- we can define several wheres and combine it with pattern matching
initials :: String -> String -> String
initials firstname lastname = [f] ++ ". " ++ [l] ++ "."
  where (f:_) = firstname
        (l:_) = lastname
-- where can also be used to define entire functions instead of constants.
-- this is useful for helper functions
calcBmis :: (RealFloat a) => [(a, a)] -> [a]
calcBmis xs = [bmi w h | (w, h) <- xs]
  where bmi weight height = weight / height ^ 2

-- RECURSION. This is how a recursive max looks in haskell:
maximum' :: (Ord a) => [a] -> a
maximum' [] = error "list is empty"
maximum' [x] = x
maximum' (x:xs)
  | x > maxTail = x
  | otherwise = maxTail
  where maxTail = maximum' xs
-- another implementation uses max. remember max takes two
-- numbers and return the largest `max :: Ord a => a -> a -> a`
maximum'' :: (Ord a) => [a] -> a
maximum'' [] = error "list empty"
maximum'' [x] = x
maximum'' (x:xs) = max x (maximum'' xs)
-- replicate takes an int n and something else and returns a list
-- with n copies of that something `r :: (Int a) => a => b => [b]`
replicate' :: (Num i, Ord i) => i -> a -> [a]
replicate' n x
    | n <= 0    = []
    | otherwise = x:replicate' (n-1) x
-- I guess for didactics he decided to use a number in place of int,
-- numbers have not a ordering in general (think of complex num), so he
-- requires an ordering too. my first take was almost there but also
-- sucked a bit:
badReplicate a b
  | a == 0 = []
  | a == 1 = [b]
  | otherwise = a : badReplicate (a -1) b
-- the second pattern is not needed. also i wasn't guarding against
-- the case of having a negative number. ALL CASES MUST BE COVERED.
-- take takes a certain number of elements from a list.
-- like take 3 [5,4,3,2,1] shall return [5,4,3].
take' :: (Num a, Ord a) => a -> [b] -> [b]
take' a _
  | a <= 0 = []
take' _ [] = []
take' n (x:xs) = x : take' (n-1) xs
-- this is how you deal with multiple variables: you pattern match
-- their edge cases separately. after matching the first variable,
-- since we do not have an otherwise, we fall through to matching
-- the second variable.
-- now let's try a reverse function.
reverse' :: [a] -> [a]
reverse' [] = []
reverse' (x:xs) = (reverse' xs) ++ [x]
-- remember: the `++` operator concatenate lists, `:` add a single
-- element to the head of list.
-- this `repeat` function will put together an infinite list.
repeat' :: a -> [a]
repeat' x = x : repeat' x
weCanTakeFromInfiniteList = take 5 (repeat 3)
-- this is lazy evaluation at work. if (repeat 3) was not lazily evaluated
-- weCanTakeFromInfiniteList would never return.
zip' :: [a] -> [b] -> [(a, b)]
zip' [x] [ ] = [ ]
zip' [ ] [x] = [ ]
zip' (x:xs) (y:ys) = [(x, y)] ++ zip xs ys
